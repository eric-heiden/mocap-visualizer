<!DOCTYPE html>
<html>
<head>
	<title>MoCap Visualizer</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			color: #000;
			font-family:Monospace;
			font-size:13px;
			text-align:center;

			background-color: #fff;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			position: absolute;
			top: 0px; width: 100%;
			padding: 5px;
		}

		a {
			color: #0af;
		}
	</style>
</head>
<body>
	<div id="container"></div>

	<div id="info">camera orbit/zoom/pan with left/middle/right mouse button</div>

	<script src="js/three.min.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src="js/THREE.MeshLine.js"></script>

	<script src="js/Detector.js"></script>
	<script src="js/stats.min.js"></script>

	<script src="js/utils.js"></script>

	<script src="js/jquery-3.2.1.min.js"></script>
	<script src="js/math.min.js"></script>

	<script>
		var scene, camera, controls, stats;
		var renderer, mixer;

		var clock = new THREE.Clock();
		var url = 'js/scene-animation.json';

		var SCREEN_WIDTH = window.innerWidth;
		var SCREEN_HEIGHT = window.innerHeight;

		var container = document.getElementById('container');

		stats = new Stats();
		container.appendChild(stats.dom);

		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
		renderer.shadowMap.enabled = true;
		renderer.shadowMap.type = THREE.PCFSoftShadowMap;

		container.appendChild( renderer.domElement );

		$.getJSON("mocap/subject.json", function(subject)
		{
			scene = new THREE.Scene();
		    scene.background = new THREE.Color(0xffffff);

		    camera = new THREE.PerspectiveCamera(30, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 10000);
			camera.position.set(-200, 50, 200);

			controls = new THREE.OrbitControls( camera );

			var lights = [];
			lights[ 0 ] = new THREE.PointLight( 0xffffff, 1, 0 );
			lights[ 1 ] = new THREE.PointLight( 0xffffff, 0.1, 0 );
			lights[ 2 ] = new THREE.PointLight( 0xffffff, 0.1, 0 );

			lights[ 0 ].position.set( 0, 200, 0 );
			lights[ 1 ].position.set( 100, 200, 100 );
			lights[ 2 ].position.set( - 100, - 200, - 100 );

			lights[ 0 ].castShadow = true;
			lights[ 1 ].castShadow = true;
			lights[ 2 ].castShadow = true;

			lights[ 0 ].shadow.mapSize.width = 1024;  
			lights[ 0 ].shadow.mapSize.height = 1024; 
			lights[ 0 ].shadow.camera.near = 2;       
			lights[ 0 ].shadow.camera.far = 500;

			lights[ 1 ].shadow.mapSize.width = 1024;  
			lights[ 1 ].shadow.mapSize.height = 1024; 
			lights[ 1 ].shadow.camera.near = 2;       
			lights[ 1 ].shadow.camera.far = 500;

			lights[ 2 ].shadow.mapSize.width = 1024;  
			lights[ 2 ].shadow.mapSize.height = 1024; 
			lights[ 2 ].shadow.camera.near = 2;       
			lights[ 2 ].shadow.camera.far = 500;

			scene.add( lights[ 0 ] );
			scene.add( lights[ 1 ] );
			scene.add( lights[ 2 ] );

			// add background
			var geometry = new THREE.PlaneBufferGeometry(20000, 20000);
			var material = new THREE.MeshPhongMaterial({ shininess: 0.1 });
			var ground = new THREE.Mesh(geometry, material);
			ground.position.set(0, -50, 0);
			ground.rotation.x = -Math.PI / 2;
			scene.add(ground);

			// smaller plane that only renders shadows
			var shadowGeometry = new THREE.PlaneBufferGeometry(200, 200);
			var shadowGround = new THREE.Mesh(shadowGeometry, new THREE.ShadowMaterial({opacity: 0.5}));
			shadowGround.position.set(0, 1, 0);
			shadowGround.rotation.x = -Math.PI / 2;
            shadowGround.castShadow = false;
            shadowGround.receiveShadow = true;
			scene.add(shadowGround);

			scene.fog = new THREE.Fog(0xffffff, 1000, 10000);

			material = new THREE.MeshNormalMaterial();

			var lr = loadSubject(scene, subject);
			subject = lr.subject;
			bones = lr.bones;

			var light = new THREE.AmbientLight(0x404040); // soft white light
			scene.add(light);

			// generate keyframes to play back AMC animation
			mixer = new THREE.AnimationMixer(scene);

			loadAnimation().then(function(frames)
			{
				var positions = {};
				for (var boneName in bones)
					positions[boneName] = [];
				var times = [];
				for (var i = 0; i < frames.length; ++i)
				{
					times.push(i/100.);
					var frame = frames[i];

					// compute local bone transformation
					// given parent position, current joint, and stack of rotation matrices
					function dfs(position, node, stack)
				    {
					    var angles = [0, 0, 0];
					    var direction = [0, 0, 0];
				   		if ("direction" in node)
				        {
				            direction = math.multiply(node.direction, node.length);

				            if ("axis" in node && node.name in frame)
				            {
					            var dofs = ["rx", "ry", "rz"];
					            for (var d = 0; d < node.dof.length; ++d)
					            {
					            	var dof = node.dof[d];
					            	angles[dofs.indexOf(dof)] = frame[node.name][d];
					            }
					        }
					    }

			            var L = rotation_matrix(node, angles[0], angles[1], angles[2]);
			            stack.push(math.multiply(L, stack[stack.length-1]));

			            var d = math.multiply(direction, stack[stack.length-1]).toArray();
			            direction = new THREE.Vector3(d[0], d[1], d[2]);

			            var endPosition = new THREE.Vector3().addVectors(position, direction);

			            if (node.name != "root")
				    	{
				    		positions[node.name].push(endPosition.x);
							positions[node.name].push(endPosition.y);
							positions[node.name].push(endPosition.z);
				    	}

			            for (var name in node.children)
				        {
				            dfs(endPosition, node.children[name], stack);
				        }

					    bones[node.name] = node;
					    stack.pop();
				    }

			  		var root_matrix = rotation_matrix(bones.root, frame.root[3], frame.root[4], frame.root[5]);
			   		dfs(vectorize(frame["root"].slice(0,3)),
			   			subject.root,
			   			[root_matrix]);
				}

				var tracks = [];
				for (var jointName in positions)
				{
					if (jointName != "root")
					{
						tracks.push(new THREE.VectorKeyframeTrack(
					        	jointName + ".position",
					        	times,
					        	positions[jointName]));
					}
				}

				var animationClip = new THREE.AnimationClip("default", 0, tracks);

				animationClip.resetDuration();

				mixer.clipAction( animationClip ).play();

				animate();
			});			
		});

		window.onresize = function()
		{
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);
		};

		function animate()
		{
			requestAnimationFrame(animate);
			render();
		}

		function render()
		{
			var delta = 0.75 * clock.getDelta();

			mixer.update(delta);
			stats.update();

			renderer.render(scene, camera);
		}
	</script>
</body>
</html>